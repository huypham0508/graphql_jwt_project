# **AuthResolver - Qu·∫£n l√Ω x√°c th·ª±c ng∆∞·ªùi d√πng trong GraphQL**

## **1. Gi·ªõi thi·ªáu**
`AuthResolver` l√† m·ªôt `GraphQL Resolver` ch·ªãu tr√°ch nhi·ªám **x√°c th·ª±c ng∆∞·ªùi d√πng**, **qu·∫£n l√Ω ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω**, v√† **x·ª≠ l√Ω qu√™n m·∫≠t kh·∫©u** trong h·ªá th·ªëng. N√≥ ho·∫°t ƒë·ªông b·∫±ng c√°ch s·ª≠ d·ª•ng **JSON Web Token (JWT)** ƒë·ªÉ x√°c th·ª±c v√† b·∫£o m·∫≠t th√¥ng tin ng∆∞·ªùi d√πng.

### **C√°c ch·ª©c nƒÉng ch√≠nh:**
- **Qu·∫£n l√Ω t√†i kho·∫£n ng∆∞·ªùi d√πng:** ƒêƒÉng k√Ω, ƒëƒÉng nh·∫≠p, ƒëƒÉng xu·∫•t, c·∫≠p nh·∫≠t th√¥ng tin c√° nh√¢n.
- **Qu·∫£n l√Ω b·∫£o m·∫≠t:** Qu√™n m·∫≠t kh·∫©u, ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u b·∫±ng OTP.
- **B·∫£o v·ªá API:** Ch·ªâ cho ph√©p ng∆∞·ªùi d√πng c√≥ token h·ª£p l·ªá truy c·∫≠p d·ªØ li·ªáu.
- **Ph√¢n quy·ªÅn ng∆∞·ªùi d√πng:** Ki·ªÉm tra quy·ªÅn h·∫°n th√¥ng qua JWT.

---

## **2. Query - Truy v·∫•n d·ªØ li·ªáu ng∆∞·ªùi d√πng**
### **2.1. Ki·ªÉm tra k·∫øt n·ªëi API (`hello`)**
```typescript
@Query((_return) => String)
@UseMiddleware(VerifyTokenAll)
async hello(@Ctx() context: Context): Promise<String> {
  const id = context.user.id;
  const data = await User.findOne({ _id: id });

  if (!data) {
    return `data not found`;
  }
  return `hello ${data.userName ?? "world"}`;
}
```
- **Middleware `VerifyTokenAll`**: Ch·ªâ ng∆∞·ªùi d√πng c√≥ **JWT h·ª£p l·ªá** m·ªõi ƒë∆∞·ª£c truy c·∫≠p.
- **L·∫•y `id` t·ª´ `context.user`** (do middleware x√°c th·ª±c JWT tr∆∞·ªõc ƒë√≥).
- **T√¨m ng∆∞·ªùi d√πng trong database b·∫±ng `User.findOne({ _id: id })`**.
- **Tr·∫£ v·ªÅ `hello {userName}`** n·∫øu t√¨m th·∫•y, ng∆∞·ª£c l·∫°i tr·∫£ v·ªÅ `"data not found"`

### **2.2. L·∫•y danh s√°ch ng∆∞·ªùi d√πng (`getUsers`)**
```typescript
@Query((_return) => [IUser])
@UseMiddleware(VerifyTokenAll)
async getUsers(@Ctx() _: Context): Promise<IUser[]> {
  const data = await User.find();
  return data;
}
```
- Ch·ªâ **ng∆∞·ªùi d√πng ƒë√£ x√°c th·ª±c** m·ªõi c√≥ th·ªÉ l·∫•y danh s√°ch ng∆∞·ªùi d√πng.
- L·∫•y t·∫•t c·∫£ ng∆∞·ªùi d√πng t·ª´ database (`User.find()`).

---

## **3. Mutation - Qu·∫£n l√Ω t√†i kho·∫£n**
### **3.1. ƒêƒÉng k√Ω t√†i kho·∫£n (`register`)**
```typescript
@Mutation((_return) => UserMutationResponse)
async register(
  @Arg("registerInput") registerInput: RegisterInput,
  @Ctx() { req }: Context
): Promise<UserMutationResponse> {
```
#### **üõ† C√°ch ho·∫°t ƒë·ªông:**
1. **Nh·∫≠n d·ªØ li·ªáu ƒëƒÉng k√Ω t·ª´ `registerInput`** g·ªìm `email`, `userName`, `password`, `avatar`.
```sh
export class RegisterInput {
  @Field()
  email: string;
  @Field()
  userName: string;
  @Field()
  password: string;
  @Field({ nullable: true })
  avatar?: string;
}

```
2. **Ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i ch∆∞a**:
```typescript
   const existingUser = await User.findOne({ email });
   if (existingUser) { return { code: 400, success: false, message: req.t("Email already exists!") }; }
```
- T√¨m ki·∫øm email trong database `(User.findOne({ email }))`.
- N·∫øu email ƒë√£ t·ªìn t·∫°i, tr·∫£ v·ªÅ l·ªói 400 c√πng th√¥ng b√°o "Email already exists!".
```sh
const defaultRole = await RoleModel.findOne({ name: "member" });
```
- T√¨m role m·∫∑c ƒë·ªãnh (v√≠ d·ª•: "member") ƒë·ªÉ g√°n v√†o t√†i kho·∫£n m·ªõi.




3. **T·∫°o m·∫≠t kh·∫©u hash b·∫±ng `Bcrypt.hashPassword(password)`**.
```sh
const hashedPassword = await Bcrypt.hashPassword(password);
```
- D√πng class Bcrypt ƒë√£ t·∫°o tr∆∞·ªõc ƒë√≥ ƒë·ªÉ bƒÉm m·∫≠t kh·∫©u (hashPassword).
```sh 
public static hashPassword(plaintextPassword: string) {
        return bcrypt.hash(plaintextPassword, ConfigBcrypt.saltRounds);
    }
```
- L√Ω do: Kh√¥ng bao gi·ªù l∆∞u m·∫≠t kh·∫©u d·∫°ng text thu·∫ßn trong database.
4. **L∆∞u t√†i kho·∫£n v√†o databasee**.
```sh
const newUser = new User({
  email,
  userName,
  password: hashedPassword,
  avatar: avatar,
  otp: undefined,
  otpExpirationTime: undefined,
  role: defaultRole,
});
await newUser.save();
```
5. **Tr·∫£ v·ªÅ `"User registered successfully!"`**.

---

### **3.2. ƒêƒÉng nh·∫≠p (`login`)**
```typescript
@Mutation((_return) => UserMutationResponse)
async login(
  @Arg("loginInput") { email, password }: LoginInput,
  @Ctx() { req, res }: Context
): Promise<UserMutationResponse> {
```
#### **üõ† C√°ch ho·∫°t ƒë·ªông:**
1. **T√¨m ng∆∞·ªùi d√πng trong database b·∫±ng email**.
```sh
const checkAccount = await User.findOne({ email });

if (!checkAccount) {
  return {
    code: 400,
    success: false,
    message: req.t("Email not found!"),
  };
}

```
- `User.findOne({ email })`: T√¨m ki·∫øm t√†i kho·∫£n theo email trong database.
N·∫øu kh√¥ng t√¨m th·∫•y, tr·∫£ v·ªÅ l·ªói 400 v·ªõi th√¥ng b√°o "Email not found!".

2. **So s√°nh m·∫≠t kh·∫©u nh·∫≠p v√†o v·ªõi m·∫≠t kh·∫©u ƒë√£ hash**.
```sh
let hashPassword = checkAccount?.password ?? "";
const checkPassword = await Bcrypt.comparePassword(password, hashPassword);

if (!checkPassword) {
  return {
    code: 400,
    success: false,
    message: req.t("Password error!"),
  };
}
```
```sh
public static comparePassword(plaintextPassword: string, hash: string) {
        return bcrypt.compare(plaintextPassword, hash);
    }
```

- hashPassword l·∫•y m·∫≠t kh·∫©u ƒë√£ m√£ h√≥a t·ª´ database (n·∫øu c√≥, n·∫øu kh√¥ng th√¨ l√† chu·ªói r·ªóng "").
- Bcrypt.comparePassword(password, hashPassword): So s√°nh m·∫≠t kh·∫©u nh·∫≠p v√†o v·ªõi m·∫≠t kh·∫©u ƒë√£ l∆∞u (s·ª≠ d·ª•ng bcrypt ƒë·ªÉ hash v√† so s√°nh).
N·∫øu sai, tr·∫£ v·ªÅ l·ªói "Password error!".

3. **N·∫øu ƒë√∫ng**, t·∫°o **Access Token** v√† **Refresh Token**.

```sh
const userModel: TokenPayLoad = {
      id: checkAccount.id,
      email: checkAccount.email,
      userName: checkAccount.userName,
      tokenPermissions: Role.ALL,
      role: checkAccount.role,
    };
const refreshToken = AuthMiddleware.sendRefreshToken(res, userModel);
```
`sendRefreshToken(res, userModel):`
- G·ª≠i refresh token ƒë·∫øn client (th∆∞·ªùng l√† qua cookie HTTP-Only ƒë·ªÉ b·∫£o m·∫≠t).
- Refresh token gi√∫p user t·ª± ƒë·ªông l√†m m·ªõi accessToken m√† kh√¥ng c·∫ßn ƒëƒÉng nh·∫≠p l·∫°i.
4. **Tr·∫£ v·ªÅ th√¥ng tin ng∆∞·ªùi d√πng v√† token**.
```sh
return {
      code: 200,
      success: true,
      message: req.t("Logged in successfully!"),
      accessToken: AuthMiddleware.createToken(ConfigJWT.create_token_type, userModel),
      refreshToken: refreshToken ?? "",
      user: {
        id: checkAccount._id,
        email: checkAccount.email,
        userName: checkAccount.userName,
        password: "",
        avatar: checkAccount.avatar,
        role: checkAccount.role
      },
```
---

### **3.3. ƒêƒÉng xu·∫•t (`logout`)**
```typescript
@Mutation((_return) => UserMutationResponse)
async logout(
  @Arg("id", (_type) => ID) id: any,
  @Ctx() { req, res }: Context
): Promise<UserMutationResponse> {
```
#### **üõ† C√°ch ho·∫°t ƒë·ªông:**
1. **X√°c th·ª±c ng∆∞·ªùi d√πng b·∫±ng ID**.
2. **X√≥a token** kh·ªèi database.
```sh
existingUser.token = "";
await existingUser.save();

```
3. **X√≥a cookie `refreshToken` trong cookie**.
```sh
res.clearCookie(ConfigJWT.REFRESH_TOKEN_COOKIE_NAME, {
  httpOnly: true,
  secure: true,
  sameSite: "lax",
  path: "/refresh_token",
});
```
- `res.clearCookie()`: X√≥a cookie ch·ª©a refresh token ƒë·ªÉ user b·ªã ƒëƒÉng xu·∫•t.
- `httpOnly: true`: NgƒÉn ch·∫∑n JavaScript truy c·∫≠p cookie.
- `secure: true`: Ch·ªâ g·ª≠i cookie qua HTTPS (ch·∫∑n t·∫•n c√¥ng MITM).
- `sameSite: "lax"`: Ch·∫∑n t·∫•n c√¥ng CSRF nh∆∞ng v·∫´n cho ph√©p trong m·ªôt s·ªë tr∆∞·ªùng h·ª£p c·∫ßn thi·∫øt.
- `path: "/refresh_token"`: Ch·ªâ x√≥a cookie c√≥ path /refresh_token.

4. **Tr·∫£ v·ªÅ th√¥ng b√°o ƒëƒÉng xu·∫•t th√†nh c√¥ng**.
```sh
return {
  code: 200,
  success: true,
  message: req.t("Logged out successfully!"),
};
```
- Tr·∫£ v·ªÅ tr·∫°ng th√°i th√†nh c√¥ng (`200`), x√°c nh·∫≠n ƒëƒÉng xu·∫•t.

---

## **4. Qu√™n m·∫≠t kh·∫©u & ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u**
### **4.1. Y√™u c·∫ßu m√£ OTP ƒë·ªÉ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u (`forgotPassword`)**
```typescript
@Mutation((_return) => ForgotPasswordResponse)
async forgotPassword(
  @Arg("email") email: string,
  @Ctx() { req }: Context
): Promise<ForgotPasswordResponse> {
```
#### **üõ† C√°ch ho·∫°t ƒë·ªông:**
1. **Ki·ªÉm tra xem email c√≥ t·ªìn t·∫°i kh√¥ng**.
2. **T·∫°o m√£ OTP ng·∫´u nhi√™n b·∫±ng `generateOTP()`**.
3. **G·ª≠i OTP ƒë·∫øn email c·ªßa ng∆∞·ªùi d√πng b·∫±ng `sendEmail()`**.
4. **L∆∞u OTP v√†o database v·ªõi th·ªùi gian h·∫øt h·∫°n**.

---

### **4.2. X√°c th·ª±c m√£ OTP (`submitOTP`)**
```typescript
@Mutation((_return) => ForgotPasswordResponse)
async submitOTP(
  @Arg("email") email: string,
  @Arg("otp") otp: string,
  @Ctx() { req }: Context
): Promise<ForgotPasswordResponse> {
```
#### **üõ† C√°ch ho·∫°t ƒë·ªông:**
1. **T√¨m ng∆∞·ªùi d√πng b·∫±ng email**.
2. **So s√°nh OTP nh·∫≠p v√†o v·ªõi OTP trong database**.
3. **Ki·ªÉm tra OTP c√≥ h·∫øt h·∫°n kh√¥ng**.
4. **N·∫øu h·ª£p l·ªá, t·∫°o Access Token t·∫°m th·ªùi ƒë·ªÉ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u**.

---

### **4.3. ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u (`resetPassword`)**
```typescript
@UseMiddleware(VerifyTokenForgotPassword)
@Mutation((_return) => ForgotPasswordResponse)
async resetPassword(
  @Arg("newPassword") newPassword: string,
  @Ctx() { req, user: payloadVerify }: Context
): Promise<ForgotPasswordResponse> {
```
#### **üõ† C√°ch ho·∫°t ƒë·ªông:**
1. **Middleware `VerifyTokenForgotPassword`** ƒë·∫£m b·∫£o ch·ªâ ng∆∞·ªùi d√πng c√≥ token h·ª£p l·ªá m·ªõi c√≥ th·ªÉ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u.
2. **T·∫°o m·∫≠t kh·∫©u hash m·ªõi b·∫±ng `Bcrypt.hashPassword()`**.
3. **L∆∞u m·∫≠t kh·∫©u m·ªõi v√†o database**.
4. **Tr·∫£ v·ªÅ th√¥ng b√°o ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u th√†nh c√¥ng**.

---

## **5. C·∫≠p nh·∫≠t th√¥ng tin c√° nh√¢n (`updateUser`)**
```typescript
@UseMiddleware(VerifyTokenAll)
@Mutation((_return) => UserMutationResponse)
async updateUser(
  @Arg("updateUserInput") updateUserInput: UpdateUserInput,
  @Ctx() context: Context
): Promise<UserMutationResponse> {
```
#### **üõ† C√°ch ho·∫°t ƒë·ªông:**
1. **Middleware `VerifyTokenAll` ƒë·∫£m b·∫£o ch·ªâ ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p m·ªõi c√≥ th·ªÉ c·∫≠p nh·∫≠t th√¥ng tin**.
2. **T√¨m ng∆∞·ªùi d√πng trong database b·∫±ng ID**.
3. **C·∫≠p nh·∫≠t th√¥ng tin `userName` ho·∫∑c `avatar` n·∫øu c√≥**.
4. **L∆∞u thay ƒë·ªïi v√†o database**.
5. **Tr·∫£ v·ªÅ th√¥ng tin m·ªõi c·ªßa ng∆∞·ªùi d√πng**.

---

## **6. T·ªïng k·∫øt**
| Ch·ª©c nƒÉng | M√¥ t·∫£ |
|-----------|------------|
| `hello` | Ki·ªÉm tra API ho·∫°t ƒë·ªông |
| `getUsers` | L·∫•y danh s√°ch ng∆∞·ªùi d√πng |
| `register` | ƒêƒÉng k√Ω t√†i kho·∫£n m·ªõi |
| `login` | ƒêƒÉng nh·∫≠p v√† c·∫•p Access Token |
| `logout` | X√≥a token v√† ƒëƒÉng xu·∫•t |
| `forgotPassword` | G·ª≠i OTP ƒë·ªÉ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u |
| `submitOTP` | X√°c th·ª±c OTP |
| `resetPassword` | ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u |
| `updateUser` | C·∫≠p nh·∫≠t th√¥ng tin c√° nh√¢n |

üöÄ **H·ªá th·ªëng `AuthResolver` cung c·∫•p gi·∫£i ph√°p b·∫£o m·∫≠t to√†n di·ªán cho x√°c th·ª±c ng∆∞·ªùi d√πng tr√™n GraphQL!**
